{"version":3,"file":"event_emitter.js","sourceRoot":"","sources":["../../../src/event_emitter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * A listener class.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n\nexport type Listener<T> = (ev: T) => (boolean | void);\n\nexport type StringKeys<T> = Extract<keyof T, string>;\n\n/**\n * A map of event name to listener array.\n */\ntype SpecializedMap<Events> = {\n  [P in StringKeys<Events>]: Listener<Events[P]>[];\n};\n\n/**\n * A listener for listening on the \"*\" event: the ``ev`` parameter accepts the\n * union of all possible event types defined in the ``Events`` map.\n */\nexport type GeneralListener<Events> =\n  (name: string, ev: Events[keyof Events]) => (boolean | void);\n\n/**\n * This is an interface that can be used to hide the ``_emit`` method.\n */\nexport interface Consuming<Events> {\n  addEventListener<T extends StringKeys<Events>>(\n    eventName: T, listener: Listener<Events[T]>): void;\n  addEventListener(\n    eventName: \"*\", listener: GeneralListener<Events>): void;\n\n  addOneTimeEventListener<T extends StringKeys<Events>>(\n    eventName: T,\n    listener: Listener<Events[T]>): any;\n  addOneTimeEventListener(\n    eventName: \"*\",\n    listener: GeneralListener<Events>): any;\n\n  removeEventListener<T extends StringKeys<Events>>(\n    eventName: T, listener: Listener<Events[T]>): void;\n  removeEventListener(\n    eventName: \"*\", listener: GeneralListener<Events>): void;\n\n  removeAllListeners<T extends StringKeys<Events>>(eventName: T | \"*\"): void;\n}\n\n/**\n * The ``Event`` parameter passed to the class must be an interface that maps\n * event names to the type of data that the event subscribers will get.\n *\n *     interface Events {\n *       \"foo\": FooData,\n *       \"bar\": BarData,\n *     }\n *\n * The code that wishes to emit an event calls ``_emit`` to emit events. For\n * instance, if ``_emit(\"foo\", {beep: 3})`` is called, this will result in all\n * listeners on event ``\"foo\"`` being called and passed the object ``{beep:\n * 3}``. Any listener returning the value ``false`` ends the processing of the\n * event.\n *\n * This class also supports listening on events in a generic way, by listening\n * to the event named \"\\*\". Listeners on such events have the signature\n * ``listener(name, ev)``. When the ``_emit`` call above is executed such\n * listener will be called with ``name`` set to ``\"foo\"`` and ``ev`` set to\n * ``{beep: 3}``. Listeners on \"\\*\" are executed before the other\n * listeners. Therefore, if they return the value ``false``, they prevent the\n * other listeners from executing.\n */\nexport class EventEmitter<Events> implements Consuming<Events> {\n  private _eventListeners: SpecializedMap<Events> = Object.create(null);\n  private _generalListeners: GeneralListener<Events>[] = [];\n  private _trace: boolean = false;\n\n  /**\n   * Adds a listener for an event. The order in which event listeners are\n   * added matters. An earlier event listener returning ``false`` will prevent\n   * later listeners from being called.\n   *\n   * @param eventName The name of the event to listen to.\n   *\n   * @param listener The function that will be called when\n   * the event occurs.\n   */\n  addEventListener<T extends StringKeys<Events>>(\n    eventName: T, listener: Listener<Events[T]>): void;\n  addEventListener(\n    eventName: \"*\", listener: GeneralListener<Events>): void;\n  addEventListener<T extends StringKeys<Events>>(\n    eventName: \"*\" | T,\n    listener: Listener<Events[T]> | GeneralListener<Events>): void {\n    if (eventName === \"*\") {\n      this._generalListeners.push(listener as GeneralListener<Events>);\n    }\n    else {\n      let listeners = this._eventListeners[eventName];\n      if (listeners === undefined) {\n        listeners = this._eventListeners[eventName] = [];\n      }\n      listeners.push(listener as Listener<Events[T]>);\n    }\n  }\n\n  /**\n   * Adds a one-time listener for an event. The listener will be called only\n   * once. If this method is called more than once with the same listener, the\n   * listener will be called for each call made to this method. The order in\n   * which event listeners are added matters. An earlier event listener\n   * returning ``false`` will prevent later listeners from being called.\n   *\n   * @param eventName The name of the event to listen to.\n   *\n   * @param listener The function that will be called when the event occurs.\n   *\n   * @returns This method returns an opaque identifier which uniquely\n   * identifies this addition operation. If the caller ever wants to undo this\n   * addition at a later time using [[removeEventListener]], it can pass this\n   * return value as the listener to remove. (Client code peeking at the\n   * return value and relying on what it finds does so at its own risk. The\n   * way the identifier is created could change in future versions of this\n   * code.)\n   */\n  addOneTimeEventListener<T extends StringKeys<Events>>(\n    eventName: T,\n    listener: Listener<Events[T]>): any;\n  addOneTimeEventListener(\n    eventName: \"*\",\n    listener: GeneralListener<Events>): any;\n  addOneTimeEventListener<T extends StringKeys<Events>>(\n    eventName: \"*\" | T,\n    listener: Listener<Events[T]> | GeneralListener<Events>): any {\n    // We perform casts as any here to indicate to TypeScript that it is\n    // safe to pass this stub.\n    const me = (...args: any[]) => {\n      this.removeEventListener(eventName as any, me);\n\n      return (listener as any).apply(this, args);\n    };\n\n    this.addEventListener(eventName as any, me);\n\n    return me;\n  }\n\n  /**\n   * Removes a listener. Calling this method on a listener that is not\n   * actually listening to events is a noop.\n   *\n   * @param eventName The name of the event that was listened to.\n   *\n   * @param listener The handler to remove.\n   */\n  removeEventListener<T extends StringKeys<Events>>(\n    eventName: T, listener: Listener<Events[T]>): void;\n  removeEventListener(\n    eventName: \"*\", listener: GeneralListener<Events>): void;\n  removeEventListener<T extends StringKeys<Events>>(\n    eventName: \"*\" | T,\n    listener: Listener<Events[T]> | GeneralListener<Events>): void {\n    const listeners = (eventName === \"*\") ?\n      this._generalListeners :\n      this._eventListeners[eventName];\n\n    if (listeners === undefined) {\n      return;\n    }\n\n    const index = (listeners as any[]).lastIndexOf(listener);\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * Removes all listeners for a specific event.\n   *\n   * @param eventName The event whose listeners must all be removed.\n   */\n  removeAllListeners<T extends StringKeys<Events>>(eventName: \"*\" | T): void {\n    if (eventName === \"*\") {\n      this._generalListeners = [];\n    }\n    else {\n      this._eventListeners[eventName] = [];\n    }\n  }\n\n  /**\n   * This is the function that must be called to indicate that an event has\n   * occurred.\n   *\n   * @param eventName The name of the event to emit.\n   *\n   * @param ev The event data to provide to handlers. The type can be\n   * anything.\n   */\n  public _emit<T extends StringKeys<Events>>(eventName: T,\n                                             ev: Events[T]): void {\n    if (this._trace) {\n      // tslint:disable-next-line: no-console\n      console.log(\"simple_event_emitter emitting:\", eventName, \"with:\", ev);\n    }\n\n    {\n      let listeners = this._generalListeners;\n      if (listeners.length > 0) {\n        // We take a copy so that if any of the handlers add or remove\n        // listeners, they don't disturb our work here.\n        listeners = listeners.slice();\n\n        for (const listener of listeners) {\n          const ret = listener.call(undefined, eventName, ev);\n          if (ret === false) {\n            return;\n          }\n        }\n      }\n    }\n\n    {\n      let listeners = this._eventListeners[eventName];\n      if (listeners !== undefined && listeners.length > 0) {\n        // We take a copy so that if any of the handlers add or remove\n        // listeners, they don't disturb our work here.\n        listeners = listeners.slice();\n\n        for (const listener of listeners) {\n          const ret = listener.call(undefined, ev);\n          if (ret === false) {\n            return;\n          }\n        }\n      }\n    }\n  }\n}\n//  LocalWords:  Mangalam MPL Dubeau noop ev\n"]}