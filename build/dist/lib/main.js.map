{"version":3,"file":"main.js","sourceRoot":"","sources":["../../../src/main.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Main module of salve-dom.\n * @author Louis-Dominique Dubeau\n * @license MPL 2.0\n * @copyright Mangalam Research Center for Buddhist Languages\n */\n// import { ConcreteName, DefaultNameResolver, EName, EventSet, Grammar,\n//          GrammarWalker, ValidationError } from \"./lib/salve\";\n\n// @ts-ignore\nimport { ConcreteName, DefaultNameResolver, EName, EventSet, Grammar, GrammarWalker, ValidationError } from \"salve-annos/build/dist/salve.min\";\n\nimport { Consuming, EventEmitter } from \"./event_emitter\";\nimport { fixPrototype } from \"./tools\";\n\nexport const version = \"6.0.1\";\n\n// tslint:disable-next-line: variable-name\nconst Node = {\n  ELEMENT_NODE: 1,\n  ATTRIBUTE_NODE: 2,\n  TEXT_NODE: 3,\n  CDATA_SECTION_NODE: 4,\n  PROCESSING_INSTRUCTION_NODE: 7,\n  COMMENT_NODE: 8,\n  DOCUMENT_NODE: 9,\n  DOCUMENT_TYPE_NODE: 10,\n  DOCUMENT_FRAGMENT_NODE: 11,\n};\n\nfunction _indexOf(parent: NodeList, needle: Node): number {\n  return Array.prototype.indexOf.call(parent, needle);\n}\n\n// We check that ``Node.ATTRIBUTE_NODE`` is not undefined because eventually\n// ``ATTRIBUTE_NODE`` will be removed from the ``Node`` interface, and then we\n// could be testing ``undefined === undefined`` for objects which are not\n// attributes, which would return ``true``. The function is not very strict but\n// it should not be too lax either.\nconst attrNodeType = Node.ATTRIBUTE_NODE;\nexport const isAttr = attrNodeType !== undefined ?\n  (it: Node): it is Attr => it.nodeType === attrNodeType :\n(it: Node): it is Attr => it instanceof Attr;\n\n// validationStage values\n\nconst enum Stage {\n  START_TAG = 1,\n  CONTENTS,\n  END_TAG,\n}\n\n// Working state values\n\nexport enum WorkingState {\n  /**\n   * The validator is stopped but has not completed a validation pass yet.\n   */\n  INCOMPLETE = 1,\n  /**\n   * The validator is working on validating the document.\n   */\n  WORKING,\n  /**\n   * The validator is stopped and has found the document invalid. Note that this\n   * state happens *only* if the whole document was validated.\n   */\n  INVALID,\n  /**\n   * The validator is stopped and has found the document valid. Note that this\n   * state happens *only* if the whole document was validated.\n   */\n  VALID,\n}\n\n/**\n * Data structure for recording progress.\n *\n * @private\n *\n * @param partDone The part of the document done so far.\n *\n * @param portion A ProgressState object is created in relation to an\n * element. The element covers portion X of the total document. This parameter\n * should be X.\n */\nclass ProgressState {\n  constructor(public partDone: number,\n              public portion: number) {}\n}\n\n//\n// Note: the Validator class adds information to the Element nodes it is working\n// with by adding expando properties that start with \"wed_event_\". This deemed\n// acceptable here because:\n//\n// * The tree on which a Validator object operates is not supposed to be open to\n//   third party software. Even if it were, the chance of a clash is small.\n//\n// * The values of the expando properties are primitives (not objects or other\n//   elements).\n//\n// * We don't care about browsers or situations where expando properties are not\n//   supported.\n//\n\n/**\n * Exception to be raised if we can't find our place in the events list. It is\n * only to be raised by code in this module but the documentation is left public\n * for diagnosis purposes.\n */\nclass EventIndexException extends Error {\n  constructor() {\n    super(\n      \"undefined event_index; _validateUpTo should have taken care of that\");\n    fixPrototype(this, EventIndexException);\n  }\n}\n\n// This private utility function checks whether an event is possible *only*\n// because there is a name_pattern wildcard that allows it.\nfunction isPossibleDueToWildcard(walker: GrammarWalker<DefaultNameResolver>,\n                                 eventName: \"enterStartTag\" | \"attributeName\",\n                                 ns: string,\n                                 name: string): boolean {\n  const evs = walker.possible();\n  let matched = false;\n  for (const ev of evs) {\n    if (ev.name !== eventName) {\n      continue;\n    }\n    const { namePattern } = ev;\n    if (namePattern.match(ns, name)) {\n      // The ``.match`` test above will return true irrespective of why the\n      // namePattern matches. It could match due to a wildcard, or something\n      // else. The following ``.wildcardMatch`` test returns true only if the\n      // pattern matches due to a wildcard.\n      if (!namePattern.wildcardMatch(ns, name)) {\n        // We already know that it matches, due to *something else* than a\n        // wildcard. So we know the overall result.\n        return false;\n      }\n\n      // Keep track of whether it ever matched a wildcard.\n      matched = true;\n    }\n  }\n\n  // If it never matched any pattern at all, then we must return false.  If we\n  // get here and matched is true then it means that it matched all patterns due\n  // to wildcards.\n  return matched;\n}\n\nexport interface ErrorData {\n  error: ValidationError;\n  node?: Node | null;\n  index?: number;\n}\n\nexport interface ResetData {\n  at: number;\n}\n\nexport interface WorkingStateData {\n  state: WorkingState;\n  partDone: number;\n}\n\n/**\n * A mapping of event name to event type for the events that [[Validator]]\n * supports. This is used by TypeScript's generics but it is also a nice handy\n * reference.\n */\nexport interface Events {\n  \"error\": ErrorData;\n  \"reset-errors\": ResetData;\n  \"state-update\": WorkingStateData;\n  \"possible-due-to-wildcard-change\": Node;\n}\n\nexport interface CustomNodeProperties {\n  \"EventIndexAfter\": number;\n  \"EventIndexAfterStart\": number;\n  \"EventIndexBeforeAttributes\": number;\n  \"EventIndexAfterAttributes\": number;\n  \"PossibleDueToWildcard\": boolean;\n  \"ErrorId\": number;\n}\n\nexport type CustomNodeProperty = keyof CustomNodeProperties;\n\n/**\n * The options accepted by the validator.\n */\nexport interface Options {\n  /**\n   * A prefix string to use in front of the expando properties set by the\n   * validator.\n   */\n  prefix?: string;\n\n  /**\n   * The timeout between one cycle and the next. This is the number of\n   * milliseconds that elapse before the next cycle runs.\n   */\n  timeout?: number;\n\n  /**\n   * The maximum number of milliseconds a cycle may run. A cycle will stop after\n   * it has used the number of milliseconds listed here. Setting this to 0 means\n   * \"run until done\" which is not generally recommended.\n   */\n  maxTimespan?: number;\n\n  /**\n   * The distance between walkers under which we skip saving a walker in the\n   * cache. This is a setting you should probably not mess with unless you know\n   * what you are doing.\n   */\n  walkerCacheGap?: number;\n}\n\ninterface EventRecord {\n  name: string;\n  params: any[];\n}\n\n/**\n * A document validator. The validator assumes that the DOM tree it uses for\n * validation is always normalized: that is, there are no empty text nodes and\n * there cannot be two adjacent text nodes.\n *\n * This validator operates by scheduling work cycles. Given the way JavaScript\n * works, if the validator just validated the whole document in one shot, it\n * would take all processing power until done, and everything else would\n * block. Rather than do this, it performs a bit of work, stops, and performs\n * another bit, etc. Each bit of work is called a \"cycle\". The options passed to\n * the validator at creation determine how long a cycle may last and how much\n * time elapses between cycles. (Yes, using ``Worker``s has been considered as\n * an option but it would complicate the whole deal by quite a bit due to\n * communication costs between a ``Worker`` and the main process.)\n *\n * @param schema A ``Grammar`` object that has already been produced from\n * ``salve``.\n *\n * @param root The root of the DOM tree to validate. This root contains the\n * document to validate but is not part of the document itself.\n *\n * @param options Some options driving how the validator works.\n */\nexport class Validator {\n  private _cycleEntered: number = 0;\n  private _timeout: number = 200;\n  private _maxTimespan: number = 100;\n  private _timeoutId: number | undefined;\n  private _resetting: boolean = false;\n  private _errors: ErrorData[] = [];\n  private _errorsSeen: Record<string, boolean> = Object.create(null);\n  private readonly _boundWrapper: () => void = this._workWrapper.bind(this);\n\n  // Validation state\n  private _validationEvents: EventRecord[] = [];\n  private _validationWalker: GrammarWalker<DefaultNameResolver>;\n  private _workingState: WorkingState = WorkingState.INCOMPLETE;\n  private _partDone: number = 0;\n  private _validationStage: Stage = Stage.CONTENTS;\n  private _previousChild: Node | null = null;\n  private _validationStack: ProgressState[] = [new ProgressState(0, 1)];\n  private _curEl: Element | Document;\n  private _walkerCache: Record<number, GrammarWalker<DefaultNameResolver>> =\n    Object.create(null);\n  private _walkerCacheMax: number = -1;\n  private readonly _prefix: string = \"salveDom\";\n  // The distance between walkers under which we skip saving a walker in the\n  // cache.\n  private _walkerCacheGap: number = 100;\n  private readonly _events: EventEmitter<Events> = new EventEmitter<Events>();\n  public readonly events: Consuming<Events>;\n\n  constructor(private readonly schema: Grammar,\n              private readonly root: Element | Document,\n              options: Options = {}) {\n    for (const key of [\"timeout\", \"maxTimespan\", \"walkerCacheGap\"] as const) {\n      const value = options[key];\n      if (value === undefined) {\n        continue;\n      }\n\n      if (value < 0) {\n        throw new Error(`the value for ${key} cannot be negative`);\n      }\n\n      // There is currently no simple way to make TS realize that the key used\n      // to index this is necessarily one of the private fields of TS. If the\n      // key were not computed, there'd be no problem.\n      (this as any)[`_${key}`] = options[key];\n    }\n\n    if (options.prefix !== undefined) {\n      this._prefix = options.prefix;\n    }\n\n    this._curEl = this.root;\n    // This prevents infinite loops with possibleAt and speculativelyValidate\n    // when the logic needs to back out to the top node.\n    this._setNodeProperty(this._curEl, \"EventIndexAfterStart\", 0);\n    this._setWorkingState(WorkingState.INCOMPLETE, 0);\n    this._validationWalker = this.schema.newWalker(new DefaultNameResolver());\n    this.events = this._events;\n  }\n\n  private makeKey(key: CustomNodeProperty): string {\n    return `${this._prefix}${key}`;\n  }\n\n  /**\n   * Function allowing to get a custom properties set on ``Node`` objects by\n   * this class.\n   */\n  getNodeProperty<T extends CustomNodeProperty>(node: Node, key: T):\n  CustomNodeProperties[T] | undefined {\n    return (node as any)[this.makeKey(key)];\n  }\n\n  /**\n   * Function allowing to set a custom properties set on ``Node`` objects by\n   * this class.\n   */\n  private _setNodeProperty<T extends CustomNodeProperty>(\n    node: Node,\n    key: T,\n    value: CustomNodeProperties[T]): void {\n    (node as any)[this.makeKey(key)] = value;\n  }\n\n  private _clearNodeProperties(node: Node): void {\n    const anode = node as any;\n    delete anode[this.makeKey(\"EventIndexAfter\")];\n    delete anode[this.makeKey(\"EventIndexAfterStart\")];\n    delete anode[this.makeKey(\"EventIndexBeforeAttributes\")];\n    delete anode[this.makeKey(\"EventIndexAfterAttributes\")];\n    delete anode[this.makeKey(\"PossibleDueToWildcard\")];\n    delete anode[this.makeKey(\"ErrorId\")];\n  }\n\n  /**\n   * Starts the background validation process.\n   */\n  start(): void {\n    if (this._timeoutId !== undefined) {\n      this._stop(WorkingState.WORKING);\n    }\n\n    // When we call ``this.start``, we want the validation to start ASAP. So we\n    // do not use ``this._timeout`` here. However, we do not call\n    // ``this._workWrapper`` directly because we want to be able to call\n    // ``this.start`` from event handlers. If we did call ``this._workWrapper``\n    // directly, we'd be calling this._cycle from inside this._cycle, which is\n    // results in an internal error.\n    this._timeoutId = setTimeout(this._boundWrapper, 0);\n  }\n\n  /**\n   * Get the namespaces defined in the schema passed to the Validator.\n   *\n   * @returns The namespaces known to the schema.\n   */\n  getSchemaNamespaces(): string[] {\n    return this.schema.getNamespaces();\n  }\n\n  /**\n   * Get the namespaces used in the document. This method does not cache its\n   * information and scan the whole document independently of the current\n   * validation status.\n   *\n   * @returns An object whose keys are namespace prefixes and values are lists\n   * of namespace URIs.  The values are lists because prefixes can be redefined\n   * in a document.\n   */\n  getDocumentNamespaces(): Record<string, string[]> {\n    const ret: Record<string, string[]> = {};\n\n    function _process(node: Element | null): void {\n      if (node === null) {\n        return;\n      }\n\n      const attrIxLim = node.attributes.length;\n      for (let attrIx = 0; attrIx < attrIxLim; ++attrIx) {\n        const attr = node.attributes[attrIx];\n        if (attr.name.lastIndexOf(\"xmlns\", 0) === 0) {\n          const key = attr.name.slice(6);\n          let array = ret[key];\n          if (array === undefined) {\n            array = ret[key] = [];\n          }\n          array.push(attr.value);\n        }\n      }\n\n      let child: Element | null = node.firstElementChild;\n      while (child !== null) {\n        _process(child);\n        child = child.nextElementSibling;\n      }\n    }\n\n    _process(this.root.firstElementChild);\n\n    return ret;\n  }\n\n  /**\n   * Convenience method. The bound version of this method\n   * (``this._boundWrapper``) is what is called by the timeouts to perform the\n   * background validation.\n   */\n  private _workWrapper(): void {\n    if (this._work()) {\n      this._timeoutId = setTimeout(this._boundWrapper, this._timeout);\n    }\n  }\n\n  /**\n   * Controller method for the background validation. Keeps the validator\n   * running only until done or until the maximum time span for one run\n   * of the validator is reached.\n   *\n   * @returns False if there is no more work to do. True otherwise.\n   */\n  private _work(): boolean {\n    const startDate = Date.now();\n    while (true) { // tslint:disable-line: no-constant-condition\n      // Give a chance to other operations to work.\n      if ((this._maxTimespan > 0) &&\n          (Date.now() - startDate) >= this._maxTimespan) {\n        return true;\n      }\n\n      const ret = this._cycle();\n      if (!ret) {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Performs one cycle of validation. \"One cycle\" is an arbitrarily small unit\n   * of work.\n   *\n   * @returns False if there is no more work to be done. True otherwise.\n   *\n   * @throws {Error} When there is an internal error.\n   */\n  // tslint:disable-next-line:max-func-body-length\n  private _cycle(): boolean {\n    // If we got here after a reset, then we've finished resetting.  If we were\n    // not resetting, then this is a noop.\n    this._resetting = false;\n\n    //\n    // This check is meant to catch problems that could be hard to diagnose if\n    // wed or one of its modes had a bug such that `_cycle` is reentered from\n    // `_cycle`. This could happen during error processing, for instance. Error\n    // processing causes wed to process the errors, which causes changes in the\n    // GUI tree, which *could* (this would be a bug) cause the code of a mode to\n    // execute something like `getErrorsFor`, which could cause `_cycle` to be\n    // reentered.\n    //\n    if (this._cycleEntered > 0) {\n      throw new Error(\"internal error: _cycle is being reentered\");\n    }\n\n    if (this._cycleEntered < 0) {\n      throw new Error(\"internal error: _cycleEntered negative\");\n    }\n\n    //\n    // IMPORTANT: This variable must be decremented before exiting this\n    // method. A try...finally statement is not used here because it would\n    // prevent some virtual machines from optimizing this function.\n    //\n    this._cycleEntered++;\n\n    const walker = this._validationWalker;\n    const stack = this._validationStack;\n    const events = this._validationEvents;\n    let portion = stack[0].portion;\n    let stage = this._validationStage;\n\n    stage_change:\n    while (true) { // tslint:disable-line: no-constant-condition\n      let curEl = this._curEl;\n      switch (stage) {\n        case Stage.START_TAG: {\n          // The logic is such that if we get here curEl must be an Element.\n          curEl = curEl as Element;\n          stack.unshift(new ProgressState(this._partDone, portion));\n\n          // Handle namespace declarations. Yes, this must happen before we deal\n          // with the tag name.\n          this._fireContextEvents(walker, curEl);\n          const tagName = curEl.tagName;\n          // tslint:disable-next-line:no-non-null-assertion\n          const parent = curEl.parentNode!;\n          const curElIndex = _indexOf(parent.childNodes, curEl);\n          let ename = walker.nameResolver.resolveName(tagName, false);\n          if (ename === undefined) {\n            this._processEventResult(\n              [new ValidationError(`cannot resolve the name ${tagName}`)],\n              parent, curElIndex);\n            // This allows us to move forward. It will certainly cause a\n            // validation error, and send salve into its recovery mode for\n            // unknown elements.\n            ename = new EName(\"\", tagName);\n          }\n\n          // Check whether this element is going to be allowed only due to a\n          // wildcard.\n          this._setPossibleDueToWildcard(curEl, walker, \"enterStartTag\",\n                                         ename.ns, ename.name);\n          this._fireAndProcessEvent(walker,\n                                    \"enterStartTag\", [ename.ns, ename.name],\n                                    parent, curElIndex);\n          this._setNodeProperty(curEl, \"EventIndexBeforeAttributes\",\n                                events.length);\n          this._fireAttributeEvents(walker, curEl);\n          this._setNodeProperty(curEl, \"EventIndexAfterAttributes\",\n                                events.length);\n\n          // Leave the start tag.\n          this._fireAndProcessEvent(walker, \"leaveStartTag\", [], curEl, 0);\n\n          stage = this._validationStage = Stage.CONTENTS;\n          this._setNodeProperty(curEl, \"EventIndexAfterStart\", events.length);\n          this._cycleEntered--;\n\n          return true; // state change\n          // break would be unreachable.\n        }\n        case Stage.CONTENTS: {\n          let node = (this._previousChild === null) ?\n            // starting from scratch\n            curEl.firstChild :\n            // already validation contents\n            this._previousChild.nextSibling;\n\n          let textAccumulator = \"\";\n          let textAccumulatorNode: Node | undefined;\n\n          const flushText = () => {\n            if (textAccumulator !== \"\") {\n              const eventResult = walker.fireEvent(\"text\", [textAccumulator]);\n              if (eventResult instanceof Array) {\n                if (textAccumulatorNode === undefined) {\n                  throw new Error(\"flushText running with undefined node\");\n                }\n                // We are never without a parentNode here.\n                // tslint:disable-next-line:no-non-null-assertion\n                const parent = textAccumulatorNode.parentNode!;\n                this._processEventResult(\n                  eventResult, parent,\n                  _indexOf(parent.childNodes, textAccumulatorNode));\n              }\n            }\n            textAccumulator = \"\";\n            textAccumulatorNode = undefined;\n          };\n\n          while (node !== null) {\n            switch (node.nodeType) {\n              case Node.TEXT_NODE:\n              case Node.CDATA_SECTION_NODE:\n                // Salve does not allow multiple text events in a row. If text\n                // is encountered, then all the text must be passed to salve as\n                // a single event. We record the text and will flush it to salve\n                // later.\n                textAccumulator += (node as Text).data;\n                if (textAccumulatorNode === undefined) {\n                  textAccumulatorNode = node;\n                }\n                break;\n              case Node.ELEMENT_NODE:\n                flushText();\n                portion /= curEl.childElementCount;\n                this._curEl = curEl = node as Element;\n                stage = this._validationStage = Stage.START_TAG;\n                this._previousChild = null;\n                continue stage_change;\n              case Node.DOCUMENT_TYPE_NODE:\n              case Node.COMMENT_NODE:\n              case Node.PROCESSING_INSTRUCTION_NODE:\n                break; // We just skip over these.\n              default:\n                // Document and document fragment nodes would end up here.  Yep,\n                // if we run into these nodes, that's a problem.\n                throw new Error(`unexpected node type: ${node.nodeType}`);\n            }\n            node = node.nextSibling;\n          }\n\n          flushText();\n          stage = this._validationStage = Stage.END_TAG;\n          break;\n        }\n        case Stage.END_TAG: {\n          // We've reached the end...\n          if (curEl === this.root) {\n            const eventResult = walker.end();\n            if (eventResult instanceof Array) {\n              this._processEventResult(eventResult, curEl,\n                                       curEl.childNodes.length);\n            }\n            this._runDocumentValidation();\n            this._setNodeProperty(curEl, \"EventIndexAfter\", events.length);\n            this._partDone = 1;\n            this._stop(this._errors.length > 0 ? WorkingState.INVALID :\n                       WorkingState.VALID);\n            this._cycleEntered--;\n\n            return false;\n          }\n\n          // we need it later\n          const originalElement = curEl;\n          const tagName = (curEl as Element).tagName;\n          let ename = walker.nameResolver.resolveName(tagName, false);\n          if (ename === undefined) {\n            // We just produce the name name we produced when we encountered the\n            // start tag.\n            ename = new EName(\"\", tagName);\n          }\n          this._fireAndProcessEvent(walker,\n                                    \"endTag\", [ename.ns, ename.name],\n                                    curEl, curEl.childNodes.length);\n          this._leaveContext(walker);\n\n          // Go back to the parent\n          this._previousChild = curEl;\n          // We are never without a parentNode here.\n          // tslint:disable-next-line:no-non-null-assertion\n          this._curEl = curEl = curEl.parentNode! as Element;\n\n          let nextDone = this._partDone;\n          if (curEl !== this.root) {\n            stack.shift();\n            const first = stack[0];\n            nextDone = first.partDone += portion;\n            portion = first.portion;\n          }\n\n          this._setWorkingState(WorkingState.WORKING, nextDone);\n\n          this._setNodeProperty(originalElement, \"EventIndexAfter\",\n                                this._validationEvents.length);\n          stage = this._validationStage = Stage.CONTENTS;\n          this._cycleEntered--;\n\n          return true; // state_change\n        }\n          // break; would be unreachable\n        default:\n          throw new Error(\"unexpected state\");\n      }\n    }\n  }\n\n  /**\n   * Stops background validation.\n   */\n  stop(): void {\n    this._stop();\n  }\n\n  /**\n   * This private method takes an argument that allows setting the working state\n   * to a specific value. This is useful to reduce the number of\n   * ``state-update`` events emitted when some internal operations are\n   * performed. The alternative would be to perform a state change before or\n   * after the call to ``stop``, which would result in more events being\n   * emitted.\n   *\n   * If the parameter is unused, then the logic is that if we were not yet in a\n   * VALID or INVALID state, the stopping now leads to the INCOMPLETE state.\n   *\n   * @param state The state with which to stop.\n   */\n  private _stop(state?: WorkingState): void {\n    if (this._timeoutId !== undefined) {\n      clearTimeout(this._timeoutId);\n    }\n    this._timeoutId = undefined;\n\n    if (state === undefined) {\n      // We are stopping prematurely, update the state\n      if (this._workingState === WorkingState.WORKING) {\n        this._setWorkingState(WorkingState.INCOMPLETE, this._partDone);\n      }\n    }\n    else {\n      this._setWorkingState(state, this._partDone);\n    }\n  }\n\n  /**\n   * Run document-level validation that cannot be modeled by Relax NG.  The\n   * default implementation does nothing. Deriving classes may override it to\n   * call [[_processError]].\n   */\n  protected _runDocumentValidation(): void {} // tslint:disable-line: no-empty\n\n  /**\n   * Restarts validation from a specific point. After the call returns, the\n   * background validation will be in effect. (So calling it on a stopped\n   * validator has the side effect of starting it.)\n   *\n   * @param node The element to start validation from.\n   */\n  restartAt(node: Node): void {\n    this.resetTo(node);\n    this.start();\n  }\n\n  /**\n   * Reset validation to continue from a certain point.\n   *\n   * @param node The element to start validation from.\n   */\n  resetTo(node: Node): void {\n    // We use `this._resetting` to avoid a costly reinitialization if this\n    // method is called twice in a row before any work has had a chance to be\n    // done.\n    if (!this._resetting) {\n      this._resetting = true;\n      this._resetTo(node);\n    }\n  }\n\n  private _erase(el: Element | Document): void {\n    this._clearNodeProperties(el);\n    let child = el.firstElementChild;\n    while (child !== null) {\n      this._erase(child);\n      child = child.nextElementSibling;\n    }\n  }\n\n  /**\n   * Resets validation to continue from a specific point. Any further work done\n   * by the validator will start from the point specified.\n   *\n   * @param node The element to start validation from.\n   *\n   * @emits module:validator~Validator#reset-errors\n   */\n  // @ts-ignore\n  private _resetTo(node: Node): void {\n    // An earlier implementation was trying to be clever and to avoid restarting\n    // much earlier than strictly needed. That ended up being more costly than\n    // doing this primitive restart from 0 no matter what. Eventually, Validator\n    // should be updated so that on large documents, restarting from a location\n    // towards the end does not require revalidating the whole document. For\n    // now, since wed is used for smallish documents, it would be a premature\n    // optimization.\n\n    this._erase(this.root);\n    this._validationStage = Stage.CONTENTS;\n    this._previousChild = null;\n    this._validationWalker = this.schema.newWalker(new DefaultNameResolver());\n    this._validationEvents = [];\n    // This prevents infinite loops with possibleAt and speculativelyValidate\n    // when the logic needs to back out to the top node.\n    this._setNodeProperty(this._curEl, \"EventIndexAfterStart\", 0);\n    this._curEl = this.root;\n    this._partDone = 0;\n    this._errors = [];\n    this._errorsSeen = Object.create(null);\n    this._walkerCache = Object.create(null);\n    this._walkerCacheMax = -1;\n    /**\n     * Tells the listener that it must reset its list of errors.\n     *\n     * @event module:validator~Validator#reset-errors\n     * @type {Object}\n     * @property {integer} at The index of the first error that must\n     * be deleted. This error and all those after it must be deleted.\n     */\n\n    this._events._emit(\"reset-errors\", { at: 0 });\n  }\n\n  /**\n   * Sets the working state of the validator. Emits a \"state-update\" event if\n   * the state has changed.\n   *\n   * @param newState The new state of the validator.\n   *\n   * @param newDone The new portion of work done.\n   *\n   * @emits module:validator~Validator#state-update\n   */\n  private _setWorkingState(newState: WorkingState, newDone: number): void {\n    let changed = false;\n    if (this._workingState !== newState) {\n      this._workingState = newState;\n      changed = true;\n    }\n\n    if (this._partDone !== newDone) {\n      this._partDone = newDone;\n      changed = true;\n    }\n\n    if (changed) {\n      /**\n       * Tells the listener that the validator has changed state.\n       *\n       * @event module:validator~Validator#state-update\n       */\n      this._events._emit(\"state-update\",\n                         { state: newState, partDone: newDone });\n    }\n  }\n\n  /**\n   * Gets the validator working state.\n   *\n   * @returns The working state\n   */\n  getWorkingState(): WorkingStateData {\n    return {\n      state: this._workingState,\n      partDone: this._partDone,\n    };\n  }\n\n  /**\n   * The current set of errors.\n   */\n  get errors(): ErrorData[] {\n    return this._errors.slice();\n  }\n\n  /**\n   * Processes the result of firing a tag event. It will emit an \"error\"\n   * event for each error.\n   *\n   * @param results The results of the walker's ``fireEvent`` call.\n   *\n   * @param node The data node to which the result belongs.\n   *\n   * @param index The index into ``node`` to which the result belongs.\n   *\n   * @emits module:validator~Validator#error\n   */\n  private _processEventResult(results: ValidationError[],\n                              node?: Node | null,\n                              index?: number): void {\n    for (const result of results) {\n      this._processError({ error: result, node, index });\n    }\n  }\n\n  /**\n   * This method should be called whenever a new error is detected. It\n   * records the error and emits the corresponding event.\n   *\n   * @param error The error found.\n   *\n   * @emits module:validator~Validator#error\n   */\n  protected _processError(error: ErrorData): void {\n    /**\n     * We don't make this a method because it should only be called from\n     * ``_processError``. The way we generate new ID values works **only**\n     * because we push a new error in the list when there's no ID already set.\n     *\n     * Ensure the node has an error ID and return it. The error ID is the number\n     * set on the ``ErrorId`` property. If the node has no ID set yet, we assign\n     * one and return the new value. Otherwise, the old value is returned.\n     *\n     * @param node The node of interest.\n     *\n     * @returns The error ID.\n     */\n    const ensureErrorId = (nodeGettingId: Node) => {\n      let oldId = this.getNodeProperty(nodeGettingId, \"ErrorId\");\n      if (oldId === undefined) {\n        // The length of the error array at the time of first calling this\n        // function is good enough to serve as an ID.\n        oldId = this._errors.length;\n        this._setNodeProperty(nodeGettingId, \"ErrorId\", oldId);\n      }\n\n      return oldId;\n    };\n\n    // We must first check whether we've seen this error before, and avoid\n    // recording it again if we've seen it. This could happen when\n    // ``_getWalkerAt`` is used, because the validator may repeat firing events\n    // and processing the associated errors. We cannot just turn off error\n    // processing when ``_getWalkerAt`` is used because it may be used in cases\n    // where we are legitimately advancing the state of validation (rather than\n    // going over old stuff).\n\n    const node = error.node;\n    const errorId = node == null ? \"\" : String(ensureErrorId(node));\n\n    const key = `${errorId},${error.error.toString()}`;\n    const alreadySeen = this._errorsSeen[key];\n\n    // We want to do a strict compare with true to handle ``undefined``.\n    if (alreadySeen !== true) {\n      this._errorsSeen[key] = true;\n      this._errors.push(error);\n      /**\n       * Tells the listener that an error has occurred.\n       *\n       * @event module:validator~Validator#error\n       * @type {Object}\n       * @property {Object} error The validation error.\n       * @property {Node} node The node where the error occurred.\n       * @property {integer} index The index in this node.\n       */\n      this._events._emit(\"error\", error);\n    }\n  }\n\n  private _fireContextEvents(walker: GrammarWalker<DefaultNameResolver>,\n                             el: Element): void {\n    const attrIxLim = el.attributes.length;\n    const mapping: Record<string, string> = Object.create(null);\n    for (let attrIx = 0; attrIx < attrIxLim; ++attrIx) {\n      const attr = el.attributes[attrIx];\n      let uri: string | undefined;\n      if (attr.name === \"xmlns\") {\n        uri = \"\";\n      }\n      else if (attr.name.lastIndexOf(\"xmlns:\", 0) === 0) {\n        uri = attr.name.slice(6);\n      }\n\n      if (uri !== undefined) {\n        mapping[uri] = attr.value;\n      }\n    }\n    this._enterContextWithMapping(walker, mapping);\n  }\n\n  /**\n   * Fires all the attribute events for a given element.\n   */\n  private _fireAttributeEvents(walker: GrammarWalker<DefaultNameResolver>,\n                               el: Element): void {\n    // Find all attributes, fire events for them.\n    const attributes = el.attributes;\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < attributes.length; ++i) {\n      const attr = attributes[i];\n      // Skip those attributes which are namespace attributes.\n      if ((attr.name === \"xmlns\") ||\n          (attr.name.lastIndexOf(\"xmlns\", 0) === 0)) {\n        continue;\n      }\n      if (this._fireAttributeNameEvent(walker, attr)) {\n        this._fireAndProcessEvent(walker,\n                                  \"attributeValue\", [attr.value], attr, 0);\n      }\n    }\n  }\n\n  /**\n   * Fires an attributeName event. If the attribute name is in a namespace and\n   * cannot be resolved, the event is not fired.\n   *\n   * @returns True if the event was actually fired, false if not.\n   */\n  private _fireAttributeNameEvent(walker: GrammarWalker<DefaultNameResolver>,\n                                  attr: Attr): boolean {\n    const attrName = attr.name;\n    const ename = walker.nameResolver.resolveName(attrName, true);\n    if (ename === undefined) {\n      this._processError(\n        {error: new ValidationError(\n          `cannot resolve attribute name ${attrName}`), node: attr, index: 0});\n\n      return false;\n    }\n    this._setPossibleDueToWildcard(attr, walker, \"attributeName\",\n                                   ename.ns, ename.name);\n    this._fireAndProcessEvent(walker,\n                              \"attributeName\", [ename.ns, ename.name], attr, 0);\n\n    return true;\n  }\n\n  private _enterContextWithMapping(walker: GrammarWalker<DefaultNameResolver>,\n                                   mapping: Record<string, string>): void {\n    this._validationEvents.push({ name: \"enterContextWithMapping\",\n                                  params: [mapping] });\n    walker.nameResolver.enterContextWithMapping(mapping);\n  }\n\n  private _leaveContext(walker: GrammarWalker<DefaultNameResolver>): void {\n    this._validationEvents.push({ name: \"leaveContext\", params: [] });\n    walker.nameResolver.leaveContext();\n  }\n\n  /**\n   * Convenience method to fire events.\n   *\n   * @param walker The walker on which to fire events.\n   *\n   * @param name The name of the event to fire.\n   *\n   * @param params The event's parameters.\n   *\n   * @param el The DOM node associated with this event. Both ``el`` and ``ix``\n   * can be undefined for events that have no location associated with them.\n   *\n   * @param ix The index into ``el`` associated with this event, or a ``Node``\n   * which must be a child of ``el``. The index will be computed from the\n   * location of the child passed as this parameter in ``el``.\n   */\n  private _fireAndProcessEvent(walker: GrammarWalker<DefaultNameResolver>,\n                               name: string,\n                               params: string[],\n                               el: Node | null,\n                               ix: number): void {\n    this._validationEvents.push({ name, params });\n    const eventResult = walker.fireEvent(name, params);\n    if (eventResult instanceof Array) {\n      this._processEventResult(eventResult, el, ix);\n    }\n  }\n\n  /**\n   * Force an immediate validation which is guaranteed to go at least up to the\n   * point specified by ``container, index``, exclusively. These parameters are\n   * interpreted in the same way a DOM caret is.\n   *\n   * If the validation has not yet reached the location specified, validation\n   * will immediately be performed to reach the point. If the validation has\n   * already reached this point, then this call is a no-op.\n   *\n   * There is one exception in the way the ``container, index`` pair is\n   * interpreted. If the container is the ``root`` that was passed when\n   * constructing the Validator, then setting ``index`` to a negative value will\n   * result in the validation validating all elements **and** considering the\n   * document complete. So unclosed tags or missing elements will be\n   * reported. Otherwise, the validation goes up the ``index`` but considers the\n   * document incomplete, and won't report the errors that are normally reported\n   * at the end of a document. For instance, unclosed elements won't be\n   * reported.\n   *\n   * @param container The location up to where to validate.\n   *\n   * @param index The location up to where to validate.\n   *\n   * @param attributes Whether we are interested to validate up to and including\n   * the attribute events of the node pointed to by ``container, index``. The\n   * validation ends before leaving the start tag.\n   *\n   * @throws {Error} If ``container`` is not of element or text type.\n   */\n  private _validateUpTo(container: Node, index: number,\n                        attributes: boolean = false): void {\n    // tslint:disable-next-line:no-parameter-reassignment\n    attributes = !!attributes; // Normalize.\n    if (attributes && (container.childNodes === undefined ||\n                       container.childNodes[index].nodeType !==\n                       Node.ELEMENT_NODE)) {\n      throw new Error(\"trying to validate after attributes but before \" +\n                      \"the end of the start tag on a \" +\n                      \"node which is not an element node\");\n    }\n\n    // Set these to reasonable defaults. The rest of the code is dedicated to\n    // changing these values to those necessary depending on specifics of what\n    // is passed to the method.\n    let toInspect = container;\n    let dataKey: CustomNodeProperty = \"EventIndexAfter\";\n\n    // This function could be called with container === root if the document is\n    // empty or if the user has the caret before the start tag of the first\n    // element of the actual structure we want to validate or after the end tag\n    // of that element.\n    if (container === this.root && index <= 0) {\n      if (attributes) {\n        dataKey = \"EventIndexAfterAttributes\";\n        toInspect = container.childNodes[index];\n      }\n      else if (index === 0) {\n        // We're before the top element, no events to fire.\n        return;\n      }\n      // default values of toInspect and dataKey are what we want\n    }\n    else {\n      if (isAttr(container)) {\n        // tslint:disable-next-line:no-non-null-assertion\n        toInspect = container.ownerElement!;\n        dataKey = \"EventIndexBeforeAttributes\";\n      }\n      else {\n        switch (toInspect.nodeType) {\n          case Node.COMMENT_NODE:\n          case Node.PROCESSING_INSTRUCTION_NODE:\n          case Node.TEXT_NODE:\n          case Node.CDATA_SECTION_NODE: {\n            // This has for effect to position ourselves before all immediately\n            // adjacent sequences of text-like or irrelevant nodes.\n            const prev = (toInspect as Text).previousElementSibling;\n            if (prev === null) {\n              // tslint:disable-next-line:no-non-null-assertion\n              toInspect = toInspect.parentNode!;\n              dataKey = \"EventIndexAfterStart\";\n            }\n            else {\n              toInspect = prev;\n            }\n            break;\n          }\n          case Node.ELEMENT_NODE:\n          case Node.DOCUMENT_FRAGMENT_NODE:\n          case Node.DOCUMENT_NODE: {\n            const node = toInspect.childNodes[index];\n            if (attributes) {\n              dataKey = \"EventIndexAfterAttributes\";\n              toInspect = node;\n            }\n            else {\n              const prev = node === undefined ?\n                (toInspect as Element).lastElementChild :\n                // It may not be an element, in which case we get \"undefined\".\n                (node as Element).previousElementSibling;\n\n              if (prev !== null) {\n                toInspect = prev;\n              }\n              else {\n                dataKey = \"EventIndexAfterStart\";\n              }\n            }\n            break;\n          }\n          default:\n            throw new Error(`unexpected node type: ${container.nodeType}`);\n        }\n      }\n    }\n\n    while (this.getNodeProperty(toInspect, dataKey) === undefined) {\n      this._cycle();\n    }\n  }\n\n  /**\n   * Gets the walker which would represent the state of parsing at the point\n   * expressed by the parameters. See [[Validator.validateUpTo]] for the details\n   * of how these parameters are interpreted.\n   *\n   * **The walker returned by this function is not guaranteed to be a new\n   *   instance. Callers should not modify the walker returned but instead clone\n   *   it.**\n   *\n   * @param container\n   *\n   * @param index\n   *\n   * @param attributes Whether we are interested to validate up to but not\n   * including the attribute events of the node pointed to by ``container,\n   * index``. If ``true`` the walker returned will have all events fired on it\n   * up to, and including, those attribute events on the element pointed to by\n   * ``container, index``.\n   *\n   * @returns The walker.\n   *\n   * @throws {EventIndexException} If it runs out of events or computes an event\n   * index that makes no sense.\n   */\n  // tslint:disable-next-line:max-func-body-length cyclomatic-complexity\n  private _getWalkerAt(container: Node,\n                       index: number,\n                       attributes: boolean = false):\n  GrammarWalker<DefaultNameResolver> {\n    // tslint:disable-next-line:no-parameter-reassignment\n    attributes = !!attributes; // Normalize.\n    if (attributes && (container.childNodes === undefined ||\n                       container.childNodes[index].nodeType !==\n                       Node.ELEMENT_NODE)) {\n      throw new Error(\"trying to get a walker for attribute events on a \" +\n                      \"node which is not an element node\");\n    }\n\n    // Make sure we have the data we need.\n    this._validateUpTo(container, index, attributes);\n\n    // This function could be called with container === root if the document is\n    // empty or if the user has the caret before the start tag of the first\n    // element of the actual structure we want to validate or after the end tag\n    // of that element.\n    if (container === this.root && index <= 0) {\n      if (!attributes) {\n        // We're before the top element, no events to fire.\n        if (index === 0) {\n          return this.schema.newWalker(new DefaultNameResolver());\n        }\n\n        // _validateUpTo ensures that the current walker held by the validator\n        // is what we want. We can just return it here because it is the\n        // caller's reponsibility to either not modify it or clone it.\n        return this._validationWalker;\n      }\n    }\n\n    let walker: GrammarWalker<DefaultNameResolver> | undefined;\n    function fireTextEvent(textNode: Text): void {\n      if (walker === undefined) {\n        throw new Error(\"calling fireTextEvent without a walker\");\n      }\n      walker.fireEvent(\"text\", [textNode.data]);\n    }\n\n    if (isAttr(container)) {\n      // tslint:disable-next-line:no-non-null-assertion\n      const el = container.ownerElement!;\n      walker = this.readyWalker(\n        // tslint:disable-next-line:no-non-null-assertion\n        this.getNodeProperty(el, \"EventIndexBeforeAttributes\")!);\n\n      // Don't fire on namespace attributes.\n      if (!(container.name === \"xmlns\" || container.prefix === \"xmlns\")) {\n        walker = walker.clone();\n        this._fireAttributeNameEvent(walker, container);\n      }\n    }\n    else {\n      switch (container.nodeType) {\n        case Node.PROCESSING_INSTRUCTION_NODE:\n        case Node.COMMENT_NODE:\n        case Node.CDATA_SECTION_NODE:\n        case Node.TEXT_NODE: {\n          const prev = (container as Text).previousElementSibling;\n          let getFrom;\n          let propName: \"EventIndexAfter\" | \"EventIndexAfterStart\";\n          if (prev !== null) {\n            getFrom = prev;\n            propName = \"EventIndexAfter\";\n          }\n          else {\n            // tslint:disable-next-line:no-non-null-assertion\n            getFrom = container.parentNode!;\n            propName = \"EventIndexAfterStart\";\n          }\n          // tslint:disable-next-line:no-non-null-assertion\n          walker = this.readyWalker(this.getNodeProperty(getFrom, propName)!);\n\n          // We will attempt to fire a text event if our location is inside the\n          // current text node.\n          //\n          // A previous version of this code was also checking whether there is\n          // a text node between this text node and prev but this cannot happen\n          // because the tree on which validation is performed cannot have two\n          // adjacent text nodes.\n          if ((container.nodeType === Node.TEXT_NODE ||\n               container.nodeType === Node.CDATA_SECTION_NODE) &&\n              index > 0) {\n            walker = walker.clone();\n            fireTextEvent(container as Text);\n          }\n          break;\n        }\n        case Node.ELEMENT_NODE:\n        case Node.DOCUMENT_NODE:\n        case Node.DOCUMENT_FRAGMENT_NODE: {\n          const node = container.childNodes[index];\n          let prev;\n          let getFrom;\n          let propName: CustomNodeProperty;\n          if (!attributes) {\n            prev = node === undefined ?\n              (container as Element).lastElementChild :\n              (node as Element).previousElementSibling;\n\n            if (prev !== null) {\n              getFrom = prev;\n              propName = \"EventIndexAfter\";\n            }\n            else {\n              getFrom = container;\n              propName = \"EventIndexAfterStart\";\n            }\n          }\n          else {\n            getFrom = node;\n            propName = \"EventIndexAfterAttributes\";\n          }\n\n          // tslint:disable-next-line:no-non-null-assertion\n          walker = this.readyWalker(this.getNodeProperty(getFrom, propName)!);\n\n          if (!attributes) {\n            // We will attempt to fire a text event if another text node\n            // appeared between the node we care about and the element just\n            // before it.\n            const prevSibling = node != null ? node.previousSibling : null;\n            if (prevSibling !== null &&\n                // If the previous sibling is the same as the previous *element*\n                // sibbling, then there is nothing *between* that we need to\n                // take care of.\n                prevSibling !== prev) {\n              if (prevSibling.nodeType === Node.TEXT_NODE) {\n                walker = walker.clone();\n                fireTextEvent(prevSibling as Text);\n              }\n            }\n          }\n          break;\n        }\n        default:\n          throw new Error(`unexpected node type: ${container.nodeType}`);\n      }\n    }\n\n    return walker;\n  }\n\n  private readyWalker(eventIndex: number): GrammarWalker<DefaultNameResolver> {\n    //\n    // Perceptive readers will notice that the caching being done here could be\n    // more aggressive. It turns out that the cases where we have to clone the\n    // walker after getting it from the cache are not that frequently used, so\n    // there is little to gain from being more aggressive. Furthermore, it is\n    // likely that the caching system will change when we implement a saner way\n    // to reset validation and segment large documents into smaller chunks.\n    //\n\n    if (eventIndex === undefined) {\n      throw new EventIndexException();\n    }\n\n    const cache = this._walkerCache;\n    const max = this._walkerCacheMax;\n\n    let walker = cache[eventIndex];\n    if (walker !== undefined) {\n      return walker;\n    }\n\n    //\n    // Scan the cache for a walker we could use... rather than start from zero.\n    //\n    // There is no point in trying to be clever by using this._walkerCacheGap to\n    // start our search. If _getWalkerAt is called with decreasing positions in\n    // the document, then the gap is meaningless for our search. (Such scenario\n    // is not a normal usage pattern for _getWalkerAt but it *can* happen so we\n    // cannot assume that it won't happen.)\n    //\n    // Also, the following approach is a bit crude but trying to be clever with\n    // Object.keys() and then searching through a sorted list does not yield an\n    // appreciable improvement. Maybe on very large documents it would but this\n    // module will have to be redesigned to tackle that so there's no point now\n    // to be cleverer than this. We also tested using a sparse Array for the\n    // cache and got visibly worse performance. And we tested to see if a flag\n    // indicating if the cache has anything in it would help avoid doing a long\n    // search but it maked things worse. Basically, it seems that the typical\n    // usage pattern of _getWalkerAt is such that it will usually be called in\n    // increasing order of position in the document.\n    //\n    let searchIx = eventIndex;\n    if (searchIx >= max) {\n      searchIx = max;\n      walker = cache[searchIx];\n    }\n    else {\n      while (walker === undefined && --searchIx >= 0) {\n        walker = cache[searchIx];\n      }\n    }\n\n    if (walker !== undefined) {\n      walker = walker.clone();\n    }\n    else {\n      walker = this.schema.newWalker(new DefaultNameResolver());\n      searchIx = 0;\n    }\n\n    for (let ix = searchIx; ix < eventIndex; ++ix) {\n      const { name, params } = this._validationEvents[ix];\n      switch (name) {\n        case \"enterContextWithMapping\":\n          walker.nameResolver.enterContextWithMapping(params[0]);\n          break;\n        case \"leaveContext\":\n          walker.nameResolver.leaveContext();\n          break;\n        default:\n          walker.fireEvent(name, params);\n      }\n    }\n\n    // This is a bit arbitrary to find a balance between caching too much\n    // information and spending too much time computing walkers.\n    if (eventIndex - searchIx >= this._walkerCacheGap) {\n      cache[eventIndex] = walker;\n      this._walkerCacheMax = Math.max(eventIndex, max);\n    }\n\n    return walker;\n  }\n\n  /**\n   * Returns the set of possible events for the location specified by the\n   * parameters.\n   *\n   * @param container Together with ``index`` this parameter is interpreted to\n   * form a location.\n   *\n   * @param index Together with ``container`` this parameter is interpreted to\n   * form a location.\n   *\n   * @param attributes\n   *\n   * @returns A set of possible events.\n   */\n  possibleAt(container: Node, index: number, attributes: boolean = false):\n  EventSet {\n    const walker = this._getWalkerAt(container, index, attributes);\n\n    // Calling possible does not *modify* the walker.\n    return walker.possible();\n  }\n\n  /**\n   * Finds the locations in a node where a certain validation event is\n   * possible.\n   *\n   * @param container A node.\n   *\n   * @param name The name of the event to search for.\n   *\n   * @param params The parameters of the event to search for. The the same data\n   * as would be passed to ``fireEvent``.\n   *\n   * @returns The locations in ``container`` where the event is possible.\n   */\n  possibleWhere(container: Node, name: string, ...params: string[]): number[] {\n    const ret = [];\n\n    if (name === \"startTagAndAttributes\" || name === \"attributeNameAndValue\") {\n      throw new Error(`this method does not support ${name}: \\\nyou must use granular events instead`);\n    }\n\n    const paramString = params.toString();\n    const hasNamePattern = name === \"enterStartTag\" ||\n      name === \"attributeName\" || name === \"endTag\";\n    for (let index = 0; index <= container.childNodes.length; ++index) {\n      const possible = this.possibleAt(container, index);\n      if (hasNamePattern) {\n        // In the case where we have a name pattern as the 2nd parameter, and\n        // this pattern can be complex or have wildcards, then we have to check\n        // all events one by one for a name pattern match. (While enterStartTag,\n        // endTag and attributeName all have name patterns, endTag cannot be\n        // complex or allow wildcards because what it allows much match the tag\n        // that started the current element. This is why we do not use this\n        // branch to test for it.)\n        for (const candidate of possible) {\n          if (candidate.name === name &&\n              (candidate.param as ConcreteName).match(params[0], params[1])) {\n            ret.push(index);\n            break;\n          }\n        }\n      }\n      else {\n        for (const candidate of possible) {\n          if (candidate.name === name &&\n              candidate.params.toString() === paramString) {\n            ret.push(index);\n            break;\n          }\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  /**\n   * Validate a DOM fragment as if it were present at the point specified in the\n   * parameters in the DOM tree being validated.\n   *\n   * WARNING: This method will not catch unclosed elements. This is because the\n   * fragment is not considered to be a \"complete\" document. Unclosed elements\n   * or fragments that are not well-formed must be caught by other means.\n   *\n   * @param container The location in the tree to start at.\n   *\n   * @param index The location in the tree to start at.\n   *\n   * @param toParse The fragment to parse.\n   *\n   * @returns Returns an array of errors if there is an error. Otherwise returns\n   * false.\n   */\n  speculativelyValidate(container: Node, index: number,\n                        toParse: Node | Node[]): ErrorData[] | false {\n    let clone;\n    // tslint:disable-next-line:no-non-null-assertion\n    const doc = container.ownerDocument!;\n    if (toParse instanceof Array) {\n      clone = doc.createDocumentFragment();\n      for (const child of toParse) {\n        clone.insertBefore(child.cloneNode(true), null);\n      }\n    }\n    else {\n      clone = toParse.cloneNode(true);\n    }\n\n    const root = doc.createElement(\"div\");\n    root.insertBefore(clone, null);\n\n    return this.speculativelyValidateFragment(container, index, root);\n  }\n\n  /**\n   * Validate a DOM fragment as if it were present at the point specified in the\n   * parameters in the DOM tree being validated.\n   *\n   * WARNING: This method will not catch unclosed elements. This is because the\n   * fragment is not considered to be a \"complete\" document. Unclosed elements\n   * or fragments that are not well-formed must be caught by other means.\n   *\n   * @param container The location in the tree to start at.\n   *\n   * @param index The location in the tree to start at.\n   *\n   * @param toParse The fragment to parse. See above.\n   *\n   * @returns Returns an array of errors if there is an error. Otherwise returns\n   * false.\n   */\n  speculativelyValidateFragment(container: Node, index: number,\n                                toParse: Element): ErrorData[] | false {\n    // This is useful for pure-JS code that may be calling this.\n    if (toParse.nodeType !== Node.ELEMENT_NODE) {\n      throw new Error(\"toParse is not an element\");\n    }\n\n    // We create a new validator with the proper state to parse the fragment\n    // we've been given.\n    const dup = new Validator(this.schema, toParse);\n\n    // We have to clone the walker to prevent messing up the internal cache.\n    dup._validationWalker = this._getWalkerAt(container, index).clone();\n\n    // This forces validating the whole fragment\n    dup._validateUpTo(toParse, toParse.childNodes.length);\n    if (dup._errors.length !== 0) {\n      return dup._errors;\n    }\n\n    return false;\n  }\n\n  /**\n   * Obtain the validation errors that belong to a specific node.\n   *\n   * The term \"that belong to\" has a specific meaning here:\n   *\n   * - An error in the contents of an element belongs to the element whose\n   *   contents are incorrect. For instance if in the sequence\n   *   ``<foo><blip/></foo>`` the tag ``<blip/>`` is out of place, then the\n   *   error belongs to the node for the element ``foo``, not the node for the\n   *   element ``blip``.\n   *\n   * - Attribute errors belong to the element node to which the attributes\n   *   belong.\n   *\n   * @param node The node whose errors we want to get.\n   *\n   * @returns The errors.\n   */\n  getErrorsFor(node: Node): ErrorData[] {\n    const parent = node.parentNode;\n    if (parent === null) {\n      throw new Error(\"node without a parent!\");\n    }\n    // Validate to after the closing tag of the node.\n    this._validateUpTo(parent, _indexOf(parent.childNodes, node) + 1);\n    const ret = [];\n    for (const errorData of this._errors) {\n      if (errorData.node === node) {\n        ret.push(errorData);\n      }\n    }\n\n    return ret;\n  }\n\n  /**\n   * Sets a flag indicating whether a node is possible only due to a name\n   * pattern wildcard, and emits an event if setting the flag is a change from\n   * the previous value of the flag. It does this by inspecting the event that\n   * would be fired when ``node`` is validated. The parameters ``eventName``,\n   * ``ns`` and ``name`` are used to determine what we are looking for among\n   * possible events.\n   *\n   * @param node The node we want to check.\n   *\n   * @param walker A walker whose last fired event is the one just before the\n   * event that would be fired when validating ``node``.\n   *\n   * @param eventName The event name we are interested in.\n   *\n   * @param ns The namespace to use with the event.\n   *\n   * @param name The name to use with the event.\n   *\n   * @emits module:validator~Validator#event:possible-due-to-wildcard-change\n   *\n   */\n  private _setPossibleDueToWildcard(node: Node,\n                                    walker: GrammarWalker<DefaultNameResolver>,\n                                    eventName:\n                                    \"enterStartTag\" | \"attributeName\",\n                                    ns: string,\n                                    name: string): void {\n    const previous = this.getNodeProperty(node, \"PossibleDueToWildcard\");\n    const possible = isPossibleDueToWildcard(walker, eventName, ns, name);\n    this._setNodeProperty(node, \"PossibleDueToWildcard\", possible);\n    if (previous === undefined || previous !== possible) {\n      /**\n       * Tells the listener that a node's flag indicating whether it is possible\n       * only due to a wildcard has changed.\n       *\n       * @event module:validator~Validator#possible-due-to-wildcard-change\n       *\n       * @type {Node} The node whose flag has changed.\n       */\n      this._events._emit(\"possible-due-to-wildcard-change\", node);\n    }\n  }\n\n  /**\n   * Resolve a qualified name to an expanded name. See\n   * ``\"salve\".NameResolver.resolveName`` for what resolving means.  This method\n   * takes into account namespaces defined on parent nodes.\n   *\n   * @param container Where to perform the operation.\n   *\n   * @param index Where to perform the operation.\n   *\n   * @param name The name to rresolve.\n   *\n   * @param attributes Whether the name is an attribute's name.\n   *\n   * @return The resolved name.\n   */\n  resolveNameAt(container: Node, index: number, name: string,\n                attribute: boolean = false): EName | undefined {\n    // Even when ``attribute`` is true, we want to call ``_getWalkerAt`` with\n    // its ``attribute`` parameter ``false``.\n    return this._getWalkerAt(container, index).nameResolver\n      .resolveName(name, attribute);\n  }\n\n  /**\n   * Unresolve an expanded name to a qualified name. See\n   * ``\"salve\".NameResolver.unresolveName`` for what unresolving means. This\n   * method takes into account namespaces defined on parent nodes.\n   *\n   * @param container Where to perform the operation.\n   *\n   * @param index Where to perform the operation.\n   *\n   * @param uri The URI to unresolve.\n   *\n   * @param name The name to unresolve.\n   *\n   * @return The unresolved name.\n   */\n  unresolveNameAt(container: Node, index: number, uri: string,\n                  name: string): string | undefined {\n    return this._getWalkerAt(container, index).nameResolver\n      .unresolveName(uri, name);\n  }\n}\n\n/**\n * Exception to be raised if we cannot parse a string as an XML document.\n */\nexport class ParsingError extends Error {\n  /**\n   * @param xmlErrors A string that contains the errors reported. The library\n   * here simply serializes the error document produced by the parser.\n   */\n  constructor(readonly xmlErrors: string) {\n    super();\n    const err: Error = new Error(\"cannot parse\");\n    this.name = \"ParsingError\";\n    this.stack = err.stack;\n    this.message = err.message;\n    fixPrototype(this, ParsingError);\n  }\n}\n\n// tslint:disable-next-line:no-http-string\nconst XML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\nconst MOZILLA_NAMESPACE =\n  // tslint:disable-next-line:no-http-string\n  \"http://www.mozilla.org/newlayout/xml/parsererror.xml\";\n\n/**\n * A utility function that detects whether the parsing fails and throws an error\n * in such case.\n *\n * Note that if you pass a well-formed and correctly structured error document\n * to this function, the result will look like an error, even though it was\n * parsed properly. Given the way ``DOMParser`` reports errors, this cannot be\n * helped.\n *\n * @param source The XML to parse.\n *\n * @param win The window from which to create a ``DOMParser``.\n *\n * @returns The parsed document.\n *\n * @throws {ParsingError} If the source cannot be parsed.\n */\nexport function safeParse(source: string, win: Window = window): Document {\n  const parser = new win.DOMParser();\n  let doc: Document;\n  try {\n    doc = parser.parseFromString(source, \"text/xml\");\n  }\n  catch (ex) {\n    // On IE10/11 bad source will cause a SyntaxError.\n    if (ex.name !== \"SyntaxError\" || ex.code !== 12) {\n      throw ex;\n    }\n\n    throw new ParsingError(\"no error information available\");\n  }\n\n  // A DOMParser will generate a document that contains a description of the\n  // error(s). Unfortunately, this document is not consistently generated across\n  // browsers.\n  //\n  // However, running the code through Browser Stack on Chrome, Firefox, IE\n  // 10-100, Edge, Opera, and Safari that they boil down either to the Chrome\n  // case or the Firefox case.\n  if (\n    // Firefox\n    (doc.getElementsByTagNameNS(MOZILLA_NAMESPACE, \"parsererror\")[0] !==\n     undefined) ||\n      // Chrome\n      (doc.getElementsByTagNameNS(XML_NAMESPACE, \"parsererror\")[0] !==\n       undefined)) {\n    throw new ParsingError(doc.documentElement.outerHTML);\n  }\n\n  return doc;\n}\n"]}