{"version":3,"file":"tools.js","sourceRoot":"","sources":["../../../src/tools.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;GAQG;AACH,qCAAqC;AACrC,SAAgB,YAAY,CAAC,GAAQ,EAAE,MAAgB;IACrD,MAAM,QAAQ,GAAG,MAAM,CAAC,cAAc,KAAK,SAAS,CAAC,CAAC;QACpD,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC;QAC5B,GAAG,CAAC,SAAS,CAAC;IAEhB,IAAI,QAAQ,KAAK,MAAM,EAAE;QACvB,IAAI,MAAM,CAAC,cAAc,KAAK,SAAS,EAAE;YACvC,MAAM,CAAC,cAAc,CAAC,GAAG,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC;SAC9C;aACI;YACH,GAAG,CAAC,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC;SAClC;KACF;AACH,CAAC;AAbD,oCAaC","sourcesContent":["/**\n * This is required to work around a problem when extending built-in classes\n * like ``Error``. Some of the constructors for these classes return a value\n * from the constructor, which is then picked up by the constructors generated\n * by TypeScript (same with ES6 code transpiled through Babel), and this messes\n * up the inheritance chain.\n *\n * See https://github.com/Microsoft/TypeScript/issues/12123.\n */\n// tslint:disable-next-line:ban-types\nexport function fixPrototype(obj: any, parent: Function): void {\n  const oldProto = Object.getPrototypeOf !== undefined ?\n    Object.getPrototypeOf(obj) :\n    obj.__proto__;\n\n  if (oldProto !== parent) {\n    if (Object.setPrototypeOf !== undefined) {\n      Object.setPrototypeOf(obj, parent.prototype);\n    }\n    else {\n      obj.__proto__ = parent.prototype;\n    }\n  }\n}\n"]}